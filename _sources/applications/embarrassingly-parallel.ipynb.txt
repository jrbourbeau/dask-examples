{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<img src=\"http://dask.readthedocs.io/en/latest/_images/dask_horizontal.svg\" \n",
    "     width=\"30%\" \n",
    "     align=right\n",
    "     alt=\"Dask logo\">\n",
    "\n",
    "# Embarrassingly parallel Workloads\n",
    "\n",
    "This notebook shows how to use Dask to parallelize embarrassingly parallel workloads where you want to apply one function to many pieces of data independently.  It will show three different ways of doing this with Dask:\n",
    "\n",
    "1. [dask.delayed](http://dask.pydata.org/en/latest/delayed.html) \n",
    "2. [concurrent.Futures](https://dask.pydata.org/en/latest/futures.html) \n",
    "3. [dask.bag](https://dask.pydata.org/en/latest/bag.html)\n",
    "\n",
    "This example focuses on using Dask for building large embarrassingly parallel computation as often seen in scientific communities and on High Performance Computing facilities, for example with Monte Carlo methods. This kind of simulation assume the following:\n",
    "\n",
    " - We have a function that runs a heavy computation given some parameters.\n",
    " - We need to compute this function on many different input parameters, each function call being independent.\n",
    " - We want to gather all the results in one place for further analysis."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Start Dask Client for Dashboard\n",
    "\n",
    "Starting the Dask Client will provide a dashboard which \n",
    "is useful to gain insight on the computation.  We will also need it for the\n",
    "Futures API part of this example. Moreover, as this kind of computation\n",
    "is often launched on super computer or in the Cloud, you will probably end\n",
    "up having to start a cluster and connect a client to scale.  See \n",
    "[dask-jobqueue](https://github.com/dask/dask-jobqueue),\n",
    "[dask-kubernetes](https://github.com/dask/dask-kubernetes) or \n",
    "[dask-yarn](https://github.com/dask/dask-yarn) for easy ways to achieve this\n",
    "on respectively an HPC, Cloud or Big Data infrastructure.\n",
    "\n",
    "The link to the dashboard will become visible when you create the client below.  We recommend having it open on one side of your screen while using your notebook on the other side.  This can take some effort to arrange your windows, but seeing them both at the same time is very useful when learning."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-27T16:15:27.331886Z",
     "iopub.status.busy": "2021-01-27T16:15:27.331333Z",
     "iopub.status.idle": "2021-01-27T16:15:28.619304Z",
     "shell.execute_reply": "2021-01-27T16:15:28.619930Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<table style=\"border: 2px solid white;\">\n",
       "<tr>\n",
       "<td style=\"vertical-align: top; border: 0px solid white\">\n",
       "<h3 style=\"text-align: left;\">Client</h3>\n",
       "<ul style=\"text-align: left; list-style: none; margin: 0; padding: 0;\">\n",
       "  <li><b>Scheduler: </b>tcp://127.0.0.1:46337</li>\n",
       "  <li><b>Dashboard: </b><a href='http://127.0.0.1:8787/status' target='_blank'>http://127.0.0.1:8787/status</a></li>\n",
       "</ul>\n",
       "</td>\n",
       "<td style=\"vertical-align: top; border: 0px solid white\">\n",
       "<h3 style=\"text-align: left;\">Cluster</h3>\n",
       "<ul style=\"text-align: left; list-style:none; margin: 0; padding: 0;\">\n",
       "  <li><b>Workers: </b>1</li>\n",
       "  <li><b>Cores: </b>4</li>\n",
       "  <li><b>Memory: </b>7.29 GB</li>\n",
       "</ul>\n",
       "</td>\n",
       "</tr>\n",
       "</table>"
      ],
      "text/plain": [
       "<Client: 'tcp://127.0.0.1:46337' processes=1 threads=4, memory=7.29 GB>"
      ]
     },
     "execution_count": 1,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from dask.distributed import Client, progress\n",
    "client = Client(threads_per_worker=4, n_workers=1)\n",
    "client"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Define your computation calling function\n",
    "\n",
    "This function does a simple operation: add all numbers of a list/array together, but it also sleeps for a random amount of time to simulate real work. In real use cases, this could call another python module, or even run an executable using subprocess module."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-27T16:15:28.624291Z",
     "iopub.status.busy": "2021-01-27T16:15:28.623799Z",
     "iopub.status.idle": "2021-01-27T16:15:28.627378Z",
     "shell.execute_reply": "2021-01-27T16:15:28.626587Z"
    }
   },
   "outputs": [],
   "source": [
    "import time\n",
    "import random\n",
    "\n",
    "def costly_simulation(list_param):\n",
    "    time.sleep(random.random())\n",
    "    return sum(list_param)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We try it locally below"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-27T16:15:28.630861Z",
     "iopub.status.busy": "2021-01-27T16:15:28.630377Z",
     "iopub.status.idle": "2021-01-27T16:15:28.758626Z",
     "shell.execute_reply": "2021-01-27T16:15:28.758115Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 1.1 ms, sys: 2.24 ms, total: 3.35 ms\n",
      "Wall time: 122 ms\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "10"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "%time costly_simulation([1, 2, 3, 4])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Define the set of input parameters to call the function\n",
    "\n",
    "We will generate a set of inputs on which we want to run our simulation function. Here we use Pandas dataframe, but we could also use a simple list. Lets say that our simulation is run with four parameters called param_[a-d]."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-27T16:15:28.770751Z",
     "iopub.status.busy": "2021-01-27T16:15:28.767388Z",
     "iopub.status.idle": "2021-01-27T16:15:28.775001Z",
     "shell.execute_reply": "2021-01-27T16:15:28.775371Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>param_a</th>\n",
       "      <th>param_b</th>\n",
       "      <th>param_c</th>\n",
       "      <th>param_d</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>0.642535</td>\n",
       "      <td>0.673921</td>\n",
       "      <td>0.649070</td>\n",
       "      <td>0.473582</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>0.238075</td>\n",
       "      <td>0.327107</td>\n",
       "      <td>0.905845</td>\n",
       "      <td>0.468320</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>0.284811</td>\n",
       "      <td>0.317840</td>\n",
       "      <td>0.008652</td>\n",
       "      <td>0.638739</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>0.226146</td>\n",
       "      <td>0.638709</td>\n",
       "      <td>0.902757</td>\n",
       "      <td>0.012547</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>0.090055</td>\n",
       "      <td>0.458054</td>\n",
       "      <td>0.805512</td>\n",
       "      <td>0.892654</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "    param_a   param_b   param_c   param_d\n",
       "0  0.642535  0.673921  0.649070  0.473582\n",
       "1  0.238075  0.327107  0.905845  0.468320\n",
       "2  0.284811  0.317840  0.008652  0.638739\n",
       "3  0.226146  0.638709  0.902757  0.012547\n",
       "4  0.090055  0.458054  0.805512  0.892654"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "\n",
    "input_params = pd.DataFrame(np.random.random(size=(500, 4)),\n",
    "                            columns=['param_a', 'param_b', 'param_c', 'param_d'])\n",
    "input_params.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Without using Dask, we could call our simulation on all of these parameters using normal Python for loops.\n",
    "\n",
    "Let's only do this on a sample of our parameters as it would be quite long otherwise."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-27T16:15:28.778547Z",
     "iopub.status.busy": "2021-01-27T16:15:28.778083Z",
     "iopub.status.idle": "2021-01-27T16:15:28.781440Z",
     "shell.execute_reply": "2021-01-27T16:15:28.780563Z"
    }
   },
   "outputs": [],
   "source": [
    "results = []"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-27T16:15:28.784546Z",
     "iopub.status.busy": "2021-01-27T16:15:28.784164Z",
     "iopub.status.idle": "2021-01-27T16:15:33.140275Z",
     "shell.execute_reply": "2021-01-27T16:15:33.139476Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 99.5 ms, sys: 8.21 ms, total: 108 ms\n",
      "Wall time: 4.35 s\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "for parameters in input_params.values[:10]:\n",
    "    result = costly_simulation(parameters)\n",
    "    results.append(result)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-27T16:15:33.144701Z",
     "iopub.status.busy": "2021-01-27T16:15:33.143797Z",
     "iopub.status.idle": "2021-01-27T16:15:33.147325Z",
     "shell.execute_reply": "2021-01-27T16:15:33.147962Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[2.439107294764653,\n",
       " 1.9393468153898978,\n",
       " 1.250041135319511,\n",
       " 1.7801582637768991,\n",
       " 2.246274812514501,\n",
       " 0.8379137080528669,\n",
       " 3.1895559994461853,\n",
       " 3.375457372282469,\n",
       " 2.5696079776285274,\n",
       " 1.6850471176388986]"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "results"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Note that this is not very clever as we can easily parallelize code. \n",
    "\n",
    "There are many ways to parallelize this function in Python with libraries like `multiprocessing`, `concurrent.futures`, `joblib` or others.  These are good first steps.  Dask is a good second step, especially when you want to scale across many machines.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Use [Dask Delayed](http://dask.pydata.org/en/latest/delayed.html) to make our function lazy\n",
    "\n",
    "We can call `dask.delayed` on our funtion to make it lazy.  Rather than compute its result immediately, it records what we want to compute as a task into a graph that we'll run later on parallel hardware. Using `dask.delayed` is a relatively straightforward way to parallelize an existing code base, even if the computation isn't embarrassingly parallel like this one. \n",
    "\n",
    "Calling these lazy functions is now almost free.  In the cell below we only construct a simple graph."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-27T16:15:33.151675Z",
     "iopub.status.busy": "2021-01-27T16:15:33.151208Z",
     "iopub.status.idle": "2021-01-27T16:15:33.153302Z",
     "shell.execute_reply": "2021-01-27T16:15:33.153694Z"
    }
   },
   "outputs": [],
   "source": [
    "import dask\n",
    "lazy_results = []"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-27T16:15:33.159238Z",
     "iopub.status.busy": "2021-01-27T16:15:33.158699Z",
     "iopub.status.idle": "2021-01-27T16:15:33.161451Z",
     "shell.execute_reply": "2021-01-27T16:15:33.161855Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 548 µs, sys: 96 µs, total: 644 µs\n",
      "Wall time: 648 µs\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "\n",
    "for parameters in input_params.values[:10]:\n",
    "    lazy_result = dask.delayed(costly_simulation)(parameters)\n",
    "    lazy_results.append(lazy_result)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-27T16:15:33.166133Z",
     "iopub.status.busy": "2021-01-27T16:15:33.165387Z",
     "iopub.status.idle": "2021-01-27T16:15:33.168467Z",
     "shell.execute_reply": "2021-01-27T16:15:33.168836Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Delayed('costly_simulation-39ab5e57-030b-4943-aee3-8b17320026be')"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "lazy_results[0]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Run in parallel\n",
    "\n",
    "The `lazy_results` list contains information about ten calls to `costly_simulation` that have not yet been run.  Call `.compute()` when you want your result as normal Python objects.\n",
    "\n",
    "If you started `Client()` above then you may want to watch the status page during computation."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-27T16:15:33.177218Z",
     "iopub.status.busy": "2021-01-27T16:15:33.176742Z",
     "iopub.status.idle": "2021-01-27T16:15:35.307592Z",
     "shell.execute_reply": "2021-01-27T16:15:35.307168Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 60.3 ms, sys: 4.7 ms, total: 65 ms\n",
      "Wall time: 2.13 s\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "(2.439107294764653,\n",
       " 1.9393468153898978,\n",
       " 1.250041135319511,\n",
       " 1.7801582637768991,\n",
       " 2.246274812514501,\n",
       " 0.8379137080528669,\n",
       " 3.1895559994461853,\n",
       " 3.375457372282469,\n",
       " 2.5696079776285274,\n",
       " 1.6850471176388986)"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "%time dask.compute(*lazy_results)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Notice that this was faster than running these same computations sequentially with a for loop.  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can now run this on all of our input parameters:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-27T16:15:35.311855Z",
     "iopub.status.busy": "2021-01-27T16:15:35.311391Z",
     "iopub.status.idle": "2021-01-27T16:15:35.393569Z",
     "shell.execute_reply": "2021-01-27T16:15:35.393931Z"
    }
   },
   "outputs": [],
   "source": [
    "import dask\n",
    "lazy_results = []\n",
    "\n",
    "for parameters in input_params.values:\n",
    "    lazy_result = dask.delayed(costly_simulation)(parameters)\n",
    "    lazy_results.append(lazy_result)\n",
    "    \n",
    "futures = dask.persist(*lazy_results)  # trigger computation in the background"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "To make this go faster, we can add additional workers.\n",
    "\n",
    "(although we're still only working on our local machine, this is more practical when using an actual cluster)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-27T16:15:35.399131Z",
     "iopub.status.busy": "2021-01-27T16:15:35.398654Z",
     "iopub.status.idle": "2021-01-27T16:15:35.406446Z",
     "shell.execute_reply": "2021-01-27T16:15:35.406827Z"
    }
   },
   "outputs": [],
   "source": [
    "client.cluster.scale(10)  # ask for ten 4-thread workers"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "By looking at the Dask dashboard we can see that Dask spreads this work around our cluster, managing load balancing, dependencies, etc..\n",
    "\n",
    "Then get the result:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-27T16:15:35.409669Z",
     "iopub.status.busy": "2021-01-27T16:15:35.409166Z",
     "iopub.status.idle": "2021-01-27T16:15:46.547371Z",
     "shell.execute_reply": "2021-01-27T16:15:46.548089Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(2.439107294764653,\n",
       " 1.9393468153898978,\n",
       " 1.250041135319511,\n",
       " 1.7801582637768991,\n",
       " 2.246274812514501)"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "results = dask.compute(*futures)\n",
    "results[:5]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Using the [Futures API](http://dask.pydata.org/en/latest/futures.html)\n",
    "\n",
    "The same example can be implemented using Dask's Futures API by using the `client` object itself.  For our use case of applying a function across many inputs both Dask delayed and Dask Futures are equally useful.  The Futures API is a little bit different because it starts work immediately rather than being completely lazy.\n",
    "\n",
    "For example, notice that work starts immediately in the cell below as we submit work to the cluster:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-27T16:15:46.551835Z",
     "iopub.status.busy": "2021-01-27T16:15:46.550868Z",
     "iopub.status.idle": "2021-01-27T16:15:46.775713Z",
     "shell.execute_reply": "2021-01-27T16:15:46.776217Z"
    }
   },
   "outputs": [],
   "source": [
    "futures = []\n",
    "for parameters in input_params.values:\n",
    "    future = client.submit(costly_simulation, parameters)\n",
    "    futures.append(future)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can explicitly wait until this work is done and gather the results to our local process by calling `client.gather`:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-27T16:15:46.783003Z",
     "iopub.status.busy": "2021-01-27T16:15:46.778853Z",
     "iopub.status.idle": "2021-01-27T16:15:53.671634Z",
     "shell.execute_reply": "2021-01-27T16:15:53.671219Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[2.439107294764653,\n",
       " 1.9393468153898978,\n",
       " 1.250041135319511,\n",
       " 1.7801582637768991,\n",
       " 2.246274812514501]"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "results = client.gather(futures)\n",
    "results[:5]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "But the code above can be run in fewer lines with `client.map()` function, allowing to call a given function on a list of parameters.\n",
    "\n",
    "As for delayed, we can only start the computation and not wait for results by not calling `client.gather()` right now.\n",
    "\n",
    "It shall be noted that as Dask cluster has already performed tasks launching `costly_simulation` with Futures API on the given input parameters, the call to `client.map()` won't actually trigger any computation, and just retrieve already computed results."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-27T16:15:53.680480Z",
     "iopub.status.busy": "2021-01-27T16:15:53.679821Z",
     "iopub.status.idle": "2021-01-27T16:15:53.771070Z",
     "shell.execute_reply": "2021-01-27T16:15:53.771534Z"
    }
   },
   "outputs": [],
   "source": [
    "futures = client.map(costly_simulation, input_params.values)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Then just get the results later:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-27T16:15:53.775369Z",
     "iopub.status.busy": "2021-01-27T16:15:53.774076Z",
     "iopub.status.idle": "2021-01-27T16:15:53.958599Z",
     "shell.execute_reply": "2021-01-27T16:15:53.958005Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "500"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "results = client.gather(futures)\n",
    "len(results)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-27T16:15:53.962709Z",
     "iopub.status.busy": "2021-01-27T16:15:53.962236Z",
     "iopub.status.idle": "2021-01-27T16:15:53.968964Z",
     "shell.execute_reply": "2021-01-27T16:15:53.969362Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "2.439107294764653\n"
     ]
    }
   ],
   "source": [
    "print(results[0])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We encourage you to watch the [dashboard's status page](../proxy/8787/status) to watch on going computation."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Doing some analysis on the results\n",
    "\n",
    "One of the interests of Dask here, outside from API simplicity, is that you are able to gather the result for all your simulations in one call.  There is no need to implement a complex mechanism or to write individual results in a shared file system or object store.\n",
    "\n",
    "Just get your result, and do some computation."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Here, we will just get the results and expand our initial dataframe to have a nice view of parameters vs results for our computation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-27T16:15:53.975882Z",
     "iopub.status.busy": "2021-01-27T16:15:53.975440Z",
     "iopub.status.idle": "2021-01-27T16:15:54.014398Z",
     "shell.execute_reply": "2021-01-27T16:15:54.014805Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>param_a</th>\n",
       "      <th>param_b</th>\n",
       "      <th>param_c</th>\n",
       "      <th>param_d</th>\n",
       "      <th>result</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>317</th>\n",
       "      <td>0.758215</td>\n",
       "      <td>0.470324</td>\n",
       "      <td>0.448177</td>\n",
       "      <td>0.514461</td>\n",
       "      <td>2.191177</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>430</th>\n",
       "      <td>0.243221</td>\n",
       "      <td>0.551156</td>\n",
       "      <td>0.043593</td>\n",
       "      <td>0.930568</td>\n",
       "      <td>1.768538</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>423</th>\n",
       "      <td>0.799977</td>\n",
       "      <td>0.356802</td>\n",
       "      <td>0.164175</td>\n",
       "      <td>0.289861</td>\n",
       "      <td>1.610815</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>127</th>\n",
       "      <td>0.605329</td>\n",
       "      <td>0.563962</td>\n",
       "      <td>0.118891</td>\n",
       "      <td>0.387028</td>\n",
       "      <td>1.675210</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>280</th>\n",
       "      <td>0.335525</td>\n",
       "      <td>0.740281</td>\n",
       "      <td>0.759644</td>\n",
       "      <td>0.309081</td>\n",
       "      <td>2.144532</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "      param_a   param_b   param_c   param_d    result\n",
       "317  0.758215  0.470324  0.448177  0.514461  2.191177\n",
       "430  0.243221  0.551156  0.043593  0.930568  1.768538\n",
       "423  0.799977  0.356802  0.164175  0.289861  1.610815\n",
       "127  0.605329  0.563962  0.118891  0.387028  1.675210\n",
       "280  0.335525  0.740281  0.759644  0.309081  2.144532"
      ]
     },
     "execution_count": 20,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "output = input_params.copy()\n",
    "output['result'] = pd.Series(results, index=output.index)\n",
    "output.sample(5)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Then we can do some nice statistical plots or save result locally with pandas interface here"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-27T16:15:54.019633Z",
     "iopub.status.busy": "2021-01-27T16:15:54.018760Z",
     "iopub.status.idle": "2021-01-27T16:15:55.175121Z",
     "shell.execute_reply": "2021-01-27T16:15:55.175515Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<AxesSubplot:>"
      ]
     },
     "execution_count": 21,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "%matplotlib inline\n",
    "output['result'].plot()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-27T16:15:55.178979Z",
     "iopub.status.busy": "2021-01-27T16:15:55.178142Z",
     "iopub.status.idle": "2021-01-27T16:15:55.187694Z",
     "shell.execute_reply": "2021-01-27T16:15:55.188359Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "2.0000486143619285"
      ]
     },
     "execution_count": 22,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "output['result'].mean()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-27T16:15:55.191329Z",
     "iopub.status.busy": "2021-01-27T16:15:55.190072Z",
     "iopub.status.idle": "2021-01-27T16:15:55.218231Z",
     "shell.execute_reply": "2021-01-27T16:15:55.217814Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "242\n"
     ]
    }
   ],
   "source": [
    "filtered_output = output[output['result'] > 2]\n",
    "print(len(filtered_output))\n",
    "filtered_output.to_csv('/tmp/simulation_result.csv')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Handling very large simulation with [Bags](http://dask.pydata.org/en/latest/bag.html)\n",
    "\n",
    "The methods above work well for a size of input parameters up to about 100,000.  Above that, the Dask scheduler has trouble handling the amount of tasks to schedule to workers.  The solution to this problem is to bundle many parameters into a single task.\n",
    "You could do this either by making a new function that operated on a batch of parameters and using the delayed or futures APIs on that function.  You could also use the Dask Bag API.  This is described more in the documentation about [avoiding too many tasks](http://dask.pydata.org/en/latest/delayed-best-practices.html#avoid-too-many-tasks).\n",
    "\n",
    "Dask Bags hold onto large sequences in a few partitions.  We can convert our `input_params` sequence into a `dask.bag` collection, asking for fewer partitions (so at most 100,000, which is already huge), and apply our function on every item of the bag."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-27T16:15:55.222264Z",
     "iopub.status.busy": "2021-01-27T16:15:55.221818Z",
     "iopub.status.idle": "2021-01-27T16:15:55.388593Z",
     "shell.execute_reply": "2021-01-27T16:15:55.387931Z"
    }
   },
   "outputs": [],
   "source": [
    "import dask.bag as db\n",
    "b = db.from_sequence(list(input_params.values), npartitions=100)\n",
    "b = b.map(costly_simulation)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-27T16:15:55.409103Z",
     "iopub.status.busy": "2021-01-27T16:15:55.408589Z",
     "iopub.status.idle": "2021-01-27T16:16:04.090133Z",
     "shell.execute_reply": "2021-01-27T16:16:04.090659Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 652 ms, sys: 79.6 ms, total: 732 ms\n",
      "Wall time: 8.69 s\n"
     ]
    }
   ],
   "source": [
    "%time results_bag = b.compute()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Looking on Dashboard here, you should see only 100 tasks to run instead of 500, each taking 5x more time in average, because each one is actually calling our function 5 times."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-01-27T16:16:04.095092Z",
     "iopub.status.busy": "2021-01-27T16:16:04.094627Z",
     "iopub.status.idle": "2021-01-27T16:16:04.097017Z",
     "shell.execute_reply": "2021-01-27T16:16:04.097485Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.all(results) == np.all(results_bag)"
   ]
  }
 ],
 "metadata": {
  "anaconda-cloud": {},
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
